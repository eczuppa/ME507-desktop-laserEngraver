<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DigitalCarpenter - Lite: Quad_Encoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DigitalCarpenter - Lite
   &#160;<span id="projectnumber">Version 0.01</span>
   </div>
   <div id="projectbrief">A Nucleo L476RG based CNC Desktop CoreXY Laser Cutter &amp; Engraver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classQuad__Encoder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classQuad__Encoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Quad_Encoder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sets up the user specified timer into encoder mode and handles read values from it.  
 <a href="classQuad__Encoder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Quad__Encoder_8h_source.html">Quad_Encoder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6dc44da124e15d90d4a827438c417e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#ab6dc44da124e15d90d4a827438c417e6">Quad_Encoder</a> (uint8_t enc_sigpin_A, uint8_t enc_sigpin_B, uint8_t enc_chan_A, uint8_t enc_chan_B, TIM_TypeDef *p_eTIM, int32_t bound=1000, bool invert=false)</td></tr>
<tr class="memdesc:ab6dc44da124e15d90d4a827438c417e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for Quad Encoder Class.  <a href="classQuad__Encoder.html#ab6dc44da124e15d90d4a827438c417e6">More...</a><br /></td></tr>
<tr class="separator:ab6dc44da124e15d90d4a827438c417e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9e7bad0bc57d0a6f8700e6cf82ea75"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#adb9e7bad0bc57d0a6f8700e6cf82ea75">enc_read</a> (void)</td></tr>
<tr class="memdesc:adb9e7bad0bc57d0a6f8700e6cf82ea75"><td class="mdescLeft">&#160;</td><td class="mdescRight">handles the changing value in the timer count register and returns the total displacement in encoder ticks  <a href="classQuad__Encoder.html#adb9e7bad0bc57d0a6f8700e6cf82ea75">More...</a><br /></td></tr>
<tr class="separator:adb9e7bad0bc57d0a6f8700e6cf82ea75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a194b8850b7d34231e48c9df4e23c3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a77a194b8850b7d34231e48c9df4e23c3">enc_read_pos</a> (void)</td></tr>
<tr class="memdesc:a77a194b8850b7d34231e48c9df4e23c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts the raw value in ticks from <code><a class="el" href="classQuad__Encoder.html#adb9e7bad0bc57d0a6f8700e6cf82ea75" title="handles the changing value in the timer count register and returns the total displacement in encoder ...">enc_read()</a></code> to belt displacement in mm  <a href="classQuad__Encoder.html#a77a194b8850b7d34231e48c9df4e23c3">More...</a><br /></td></tr>
<tr class="separator:a77a194b8850b7d34231e48c9df4e23c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9fdb077cd2c1c1a800c5de872f45cd"><td class="memItemLeft" align="right" valign="top"><a id="a4d9fdb077cd2c1c1a800c5de872f45cd"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>enc_d_pos</b> (void)</td></tr>
<tr class="separator:a4d9fdb077cd2c1c1a800c5de872f45cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9644057a5337d071025e43a56b44a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#ade9644057a5337d071025e43a56b44a7">enc_zero</a> (void)</td></tr>
<tr class="memdesc:ade9644057a5337d071025e43a56b44a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets _abspos, the accumulated encoder ticks variable, to 0  <a href="classQuad__Encoder.html#ade9644057a5337d071025e43a56b44a7">More...</a><br /></td></tr>
<tr class="separator:ade9644057a5337d071025e43a56b44a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82ee109c2b2d0a72d9d15c319b7a18c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#ab82ee109c2b2d0a72d9d15c319b7a18c">enc_test</a> (void)</td></tr>
<tr class="memdesc:ab82ee109c2b2d0a72d9d15c319b7a18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">quick way to check if encoder is counting  <a href="classQuad__Encoder.html#ab82ee109c2b2d0a72d9d15c319b7a18c">More...</a><br /></td></tr>
<tr class="separator:ab82ee109c2b2d0a72d9d15c319b7a18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a29e1cb2db78d154788b91fed8d4bf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a11a29e1cb2db78d154788b91fed8d4bf">get_overflow</a> (void)</td></tr>
<tr class="memdesc:a11a29e1cb2db78d154788b91fed8d4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">quick way to check if timer overflow value for counter register is what you expect  <a href="classQuad__Encoder.html#a11a29e1cb2db78d154788b91fed8d4bf">More...</a><br /></td></tr>
<tr class="separator:a11a29e1cb2db78d154788b91fed8d4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536996cca3fad7ea8f2d55ef5f99dff6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a536996cca3fad7ea8f2d55ef5f99dff6">get_prescale</a> (void)</td></tr>
<tr class="memdesc:a536996cca3fad7ea8f2d55ef5f99dff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">quick way to check if timer prescaler is what you expect  <a href="classQuad__Encoder.html#a536996cca3fad7ea8f2d55ef5f99dff6">More...</a><br /></td></tr>
<tr class="separator:a536996cca3fad7ea8f2d55ef5f99dff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a15271549de2c8401d34c2278898167c6"><td class="memItemLeft" align="right" valign="top"><a id="a15271549de2c8401d34c2278898167c6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a15271549de2c8401d34c2278898167c6">_enc_sigpin_A</a></td></tr>
<tr class="memdesc:a15271549de2c8401d34c2278898167c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the pin that is receiving the A output signal of the encoder and is tied to the first timer channel <br /></td></tr>
<tr class="separator:a15271549de2c8401d34c2278898167c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44753d6944c49276fd9ca4350009160b"><td class="memItemLeft" align="right" valign="top"><a id="a44753d6944c49276fd9ca4350009160b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a44753d6944c49276fd9ca4350009160b">_enc_sigpin_B</a></td></tr>
<tr class="memdesc:a44753d6944c49276fd9ca4350009160b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the pin that is receiving the B output signal of the encoder and is tied to the second timer channel <br /></td></tr>
<tr class="separator:a44753d6944c49276fd9ca4350009160b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18663a38b6d3ae791393ec0390939144"><td class="memItemLeft" align="right" valign="top"><a id="a18663a38b6d3ae791393ec0390939144"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a18663a38b6d3ae791393ec0390939144">_enc_chan_A</a></td></tr>
<tr class="memdesc:a18663a38b6d3ae791393ec0390939144"><td class="mdescLeft">&#160;</td><td class="mdescRight">the timer channel number the encoder A signal pin is connected to. <br /></td></tr>
<tr class="separator:a18663a38b6d3ae791393ec0390939144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54241836a1c92b1e413d0b142d938ae"><td class="memItemLeft" align="right" valign="top"><a id="af54241836a1c92b1e413d0b142d938ae"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#af54241836a1c92b1e413d0b142d938ae">_enc_chan_B</a></td></tr>
<tr class="memdesc:af54241836a1c92b1e413d0b142d938ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">the timer channel number the encoder B signal pin is connected to. <br /></td></tr>
<tr class="separator:af54241836a1c92b1e413d0b142d938ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac291a78d55f05baabd10a156c1a32e87"><td class="memItemLeft" align="right" valign="top"><a id="ac291a78d55f05baabd10a156c1a32e87"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#ac291a78d55f05baabd10a156c1a32e87">_bound</a></td></tr>
<tr class="memdesc:ac291a78d55f05baabd10a156c1a32e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">user specified overflow threshold parameter <br /></td></tr>
<tr class="separator:ac291a78d55f05baabd10a156c1a32e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb368b055e365f46b4b29266a0844da"><td class="memItemLeft" align="right" valign="top"><a id="adcb368b055e365f46b4b29266a0844da"></a>
TIM_TypeDef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#adcb368b055e365f46b4b29266a0844da">_p_eTIM</a></td></tr>
<tr class="memdesc:adcb368b055e365f46b4b29266a0844da"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer that contains user passed-in timer object (TIM1, TIM2, etc) <br /></td></tr>
<tr class="separator:adcb368b055e365f46b4b29266a0844da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6721ec735f4e4c4a8f102942c8e88618"><td class="memItemLeft" align="right" valign="top"><a id="a6721ec735f4e4c4a8f102942c8e88618"></a>
HardwareTimer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a6721ec735f4e4c4a8f102942c8e88618">EncTmr</a></td></tr>
<tr class="memdesc:a6721ec735f4e4c4a8f102942c8e88618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of Hardware Timer class used for an instance of the encoder class. <br /></td></tr>
<tr class="separator:a6721ec735f4e4c4a8f102942c8e88618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae5dd763e022c160b50aae6a562e07a"><td class="memItemLeft" align="right" valign="top"><a id="abae5dd763e022c160b50aae6a562e07a"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#abae5dd763e022c160b50aae6a562e07a">_lastcount</a></td></tr>
<tr class="memdesc:abae5dd763e022c160b50aae6a562e07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the previous count from the timer counter register <br /></td></tr>
<tr class="separator:abae5dd763e022c160b50aae6a562e07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f9ee67e18eb094b85f3c552903c5c5"><td class="memItemLeft" align="right" valign="top"><a id="a63f9ee67e18eb094b85f3c552903c5c5"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a63f9ee67e18eb094b85f3c552903c5c5">_count</a></td></tr>
<tr class="memdesc:a63f9ee67e18eb094b85f3c552903c5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the current count from the timer counter register <br /></td></tr>
<tr class="separator:a63f9ee67e18eb094b85f3c552903c5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f5ee7ad48ca23243f8361be78860ab"><td class="memItemLeft" align="right" valign="top"><a id="a12f5ee7ad48ca23243f8361be78860ab"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a12f5ee7ad48ca23243f8361be78860ab">_abspos</a></td></tr>
<tr class="memdesc:a12f5ee7ad48ca23243f8361be78860ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">position in the global frame <br /></td></tr>
<tr class="separator:a12f5ee7ad48ca23243f8361be78860ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb6f34d580542acb0f427941452688f"><td class="memItemLeft" align="right" valign="top"><a id="a3fb6f34d580542acb0f427941452688f"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#a3fb6f34d580542acb0f427941452688f">_last_abspos</a></td></tr>
<tr class="memdesc:a3fb6f34d580542acb0f427941452688f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the previous postion in the global frame <br /></td></tr>
<tr class="separator:a3fb6f34d580542acb0f427941452688f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bb56835af757fd86c0de37c41eb5b4"><td class="memItemLeft" align="right" valign="top"><a id="aa4bb56835af757fd86c0de37c41eb5b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuad__Encoder.html#aa4bb56835af757fd86c0de37c41eb5b4">_invert</a></td></tr>
<tr class="memdesc:aa4bb56835af757fd86c0de37c41eb5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software correction for encoder wiring. <br /></td></tr>
<tr class="separator:aa4bb56835af757fd86c0de37c41eb5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Sets up the user specified timer into encoder mode and handles read values from it. </p>
<p>This is a class which uses the Hardware Timer API and some low level register setting to read a quadrature encoder on a motor and then do various useful tasks with that read value. This class has debugging methods which are documented in the .cpp file. The primary methods of this class are <code><a class="el" href="classQuad__Encoder.html#ade9644057a5337d071025e43a56b44a7" title="resets _abspos, the accumulated encoder ticks variable, to 0">enc_zero()</a></code> , <code><a class="el" href="classQuad__Encoder.html#adb9e7bad0bc57d0a6f8700e6cf82ea75" title="handles the changing value in the timer count register and returns the total displacement in encoder ...">enc_read()</a></code> , and its variants <code><a class="el" href="classQuad__Encoder.html#a77a194b8850b7d34231e48c9df4e23c3" title="converts the raw value in ticks from enc_read() to belt displacement in mm">enc_read_pos()</a></code> and <code>enc_d_pos()</code>. In general the class works by counting pulses from the quadrature encoder on a brushed DC motor by leveraging the STM32 Generic hardware timer API with a bound based over/underflow detection scheme for determining direction. This approach gives maximum performance and minimal CPU load as all counting is done with hardware giving nanosecond latencies - based on your main clock speed that is (80 MHz in the case of the Nucleo L476RG).Methods which zero the encoder, keep track of the absolute as well as the incremental postion with input from the read method are present as this is intended to be used with a desktop CNC machine. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6dc44da124e15d90d4a827438c417e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dc44da124e15d90d4a827438c417e6">&#9670;&nbsp;</a></span>Quad_Encoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Quad_Encoder::Quad_Encoder </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enc_sigpin_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enc_sigpin_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enc_chan_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enc_chan_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIM_TypeDef *&#160;</td>
          <td class="paramname"><em>p_eTIM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bound</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for Quad Encoder Class. </p>
<p>takes the two pins from the encoder that will tie to specific pins for timer functionality in encoder mode as well as the desired timer to be used (TIM1, TIM2, etc.) and has default values for the bound and invert parameters. Puts the timer into a specific encoder mode - the count register value is incremented on the rising and falling edges of each encoder singal input. And saves input parameters and other useful, state-determining values into class member data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc_sigpin_A</td><td>is the 8-bit unsigned integer representation of the timer channel (pin) the first encoder output signal is tied to (e.g PC6 or PC7 for TIM8) </td></tr>
    <tr><td class="paramname">enc_sigpin_B</td><td>is the 8-bit unsigned integer representation of the timer channel (pin) the second encoder output signal is tied to (e.g PC6 or PC7 for TIM8) </td></tr>
    <tr><td class="paramname">enc_chan_A</td><td><br  />
 </td></tr>
    <tr><td class="paramname">enc_chan_B</td><td></td></tr>
    <tr><td class="paramname">p_eTIM</td><td>the pointer of type <code>TIM_TypeDef</code> which matches the type of the predefined TIMx objects (e.g. TIM1, ..., TIM16) </td></tr>
    <tr><td class="paramname">bound</td><td>the value which determines the area where the enc_read method begins checking for an under/overflow condition </td></tr>
    <tr><td class="paramname">invert</td><td>a boolean to compensate for hardware issues - if you switch the encoder signal outputs on the timer channel pins then setting invert to true allows you to read the correct encoder values without switching the motor leads, which can sometimes be problematic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adb9e7bad0bc57d0a6f8700e6cf82ea75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9e7bad0bc57d0a6f8700e6cf82ea75">&#9670;&nbsp;</a></span>enc_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Quad_Encoder::enc_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handles the changing value in the timer count register and returns the total displacement in encoder ticks </p>
<p>Keeps track of encoder position in ticks in the returned parameter by accumulating the change in timer count register values using the HardwareTimer Library's <code>getCount()</code> method as well as positive and negative overflow handling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>the difference between the last timer register count value and the current one - checked for overflows. </td></tr>
    <tr><td class="paramname">count</td><td>the method specific variable that holds the current timer register count value. <br  />
 </td></tr>
    <tr><td class="paramname">TMR_COUNT_MAX</td><td>the overflow value for the timer, in this case for a 16 bit timer so, 65535. </td></tr>
    <tr><td class="paramname">_abspos</td><td>is the class member variable that holds the absolute position measured by the encoder it is an int32_t so it should be quite difficult to overflow unless your motor is spinning SUPER fast </td></tr>
    <tr><td class="paramname">_last_abspos</td><td>a snap shot of _abspos before being incremented by the appropriate delta - used for instantaneous velocity calculations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77a194b8850b7d34231e48c9df4e23c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a194b8850b7d34231e48c9df4e23c3">&#9670;&nbsp;</a></span>enc_read_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Quad_Encoder::enc_read_pos </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts the raw value in ticks from <code><a class="el" href="classQuad__Encoder.html#adb9e7bad0bc57d0a6f8700e6cf82ea75" title="handles the changing value in the timer count register and returns the total displacement in encoder ...">enc_read()</a></code> to belt displacement in mm </p>
<p>The radius of timing belt pulley and the conversion from ticks to radians (motor-specific) are used to convert the accrued position returned from <code>enc_read</code> to a value for the linear movement of the belt driven by the timing pulley in millimeters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MOMENT_ARM</td><td>the radius of the drive mechanism translating rotational motion to linear motion </td></tr>
    <tr><td class="paramname">TICK_TO_RAD</td><td>the number of radians per encoder tick, which is empirically determined by measuring the number of ticks accumulated in the timer count register when moving the OUTPUT shaft of the motor through 1 rotation. Do this several times, record the result and average it. Then compute by dividing 2*Pi by your result (ticks/revoltion). </td></tr>
    <tr><td class="paramname">current_tick</td><td>method specific storage of <code><a class="el" href="classQuad__Encoder.html#adb9e7bad0bc57d0a6f8700e6cf82ea75" title="handles the changing value in the timer count register and returns the total displacement in encoder ...">enc_read()</a></code> return value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab82ee109c2b2d0a72d9d15c319b7a18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82ee109c2b2d0a72d9d15c319b7a18c">&#9670;&nbsp;</a></span>enc_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Quad_Encoder::enc_test </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>quick way to check if encoder is counting </p>
<p>poll the timer with this method in a loop and print out the result to see if the timer is counting the way you expect it to be <br  />
 </p>

</div>
</div>
<a id="ade9644057a5337d071025e43a56b44a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9644057a5337d071025e43a56b44a7">&#9670;&nbsp;</a></span>enc_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Quad_Encoder::enc_zero </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>resets _abspos, the accumulated encoder ticks variable, to 0 </p>
<p>applications include prepping the encoder for use, trying to do things in an incremental positioning frame vs the global frame. Not to be confused with the Hardware Timer API's <code>setCount()</code> which changes the value of the timer counter register. </p>

</div>
</div>
<a id="a11a29e1cb2db78d154788b91fed8d4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a29e1cb2db78d154788b91fed8d4bf">&#9670;&nbsp;</a></span>get_overflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Quad_Encoder::get_overflow </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>quick way to check if timer overflow value for counter register is what you expect </p>
<p>print out the result somewhere convenient in your code, but beware of having multiple things try to print simultaneously </p>

</div>
</div>
<a id="a536996cca3fad7ea8f2d55ef5f99dff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536996cca3fad7ea8f2d55ef5f99dff6">&#9670;&nbsp;</a></span>get_prescale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Quad_Encoder::get_prescale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>quick way to check if timer prescaler is what you expect </p>
<p>print out the result somewhere convenient in your code, but beware of having multiple things try to print simultaneously </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Quad__Encoder_8h_source.html">Quad_Encoder.h</a></li>
<li><a class="el" href="Quad__Encoder_8cpp.html">Quad_Encoder.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classQuad__Encoder.html">Quad_Encoder</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
