/** @file    motionplanning.cpp 
 *  @brief 
 *           linearly interpolates between two points to create a ramp input to the controller
 *  @details This class generates ramp inputs for a classical postion PID control loop and is intended to
 *           maintain that control loop's linearity by limiting the size of the disturbances it is subjected to.
 *           First the time in microseconds it takes (at the current feed rate) for the laser to travel between
 *           the current and last setpoint are calculated. If the total travel period is less than the constant
 *           delta t for each ramp section no ramp is generated - the pointer to an array containing the current setpoint
 *           and current feed rate are returned. If it is the case the total travel period exceeds the ramp section time 
 *           differential, the number of ramp sections is calculated and array of length # of ramp sections + 2 is generated.
 *           The extra two spots hold the 
 * 
 *  @author Ethan A Czuppa
 *  @date   19 Nov 2020 Original file
 *  
 * 
 */

#include "libraries&constants.h"

/**  @brief   Motionplanning Class constructor which takes in decoded GCODE inputs and a user set discrete ramp section period
 *   @details Save all inputted arguments to class member data from the current and last lines of queued GCODE. Make the 
 *            pointer to the dynamically allocated array @c _output_ramp point to NULL in preparation for memory allocation. 
 *   @param   _setpoint_current the current position setpoints in [mm] for the motor of interest from the current line of GCODE.
 *   @param   _setpoint_last the last position setpoint in [mm] for the motor of interest from the last line of GCODE.   
 *   @param   _feed_setpoint the current feed rate in [mm/sec] that the laser is commanded to move at from the current line of GCODE.
 *   @param   _ramp_dt_period the discrete time period that each section of the ramp output is built with in [microseconds], set by the user.
 *   @param   _ramp_sections the number of discrete sections of the ramp input to the control loop generated by the @c ramp_generator() method
 *   @param   _output_ramp the pointer to the dynamically allocated array that holds what will be the ramp input to the control loop
 *                         that is controlling the motor of interest. Initialized as a null pointer to ensure 
 */
MotionPlanning::MotionPlanning(float setpoint_current, float setpoint_last, float feed_setpoint, uint32_t ramp_dt_period)
{
    // Save inputs into class member data and setup dynamic array pointer 
    _setpoint_current = setpoint_current;
    _setpoint_last = setpoint_last;
    _feed_setpoint = feed_setpoint;
    _ramp_dt_period = ramp_dt_period;
    _ramp_sections = 0;
    _output_ramp = NULL;
    _output_ramp_time = NULL;

}

/**  @brief  allocates the memory for the ramp input and initializes output_pointer
 *   @details calculates the required size of the dynamic array @c _output_ramp by 
 *            from the time required to traverse the position change specified by the
 *            current and last lines of GCODE and then creates the appropriate sized array
 *            to hold the ramp input to the control loop. To get an array with a positive integer 
 *            for the index a abbreviated approximate version of Euclid's algorithm is used to calculate
 *            the greatest common factor between the @c tot_travel_time and @c _ramp_dt_period . Since 
 *            the distance and the travel time are both floating point numbers the floating point version
 *            of the modulo (%) operator is used - @c fmodf(float_x,float_y) in the equation that calculates
 *            the number of ramp sections @c _ramp_sections.  
 *   
 *   @param   dist the distance between the current and last setpoint in [mm], used to calculate the
 *                 the time it takes for the laser to traverse the move between the current and last 
 *                 X,Y setpoints from the current and last lines of GCODE. 
 *   @param   _even a boolean that adjusts how index of the dynamically allocated array, @c _output_ramp
 *                  is augmented to include the current setpoint and feed rate. 
 * 
 */
void MotionPlanning::init_ramp(void)
{
    float dist;
    const uint8_t cols = 1; 
    //uint32_t no_ramp
    dist = abs(_setpoint_current - _setpoint_last);
    _tot_travel_period = (dist*1000000)/_feed_setpoint; // travel period in microseconds
    
    // The time the movement takes between the current line of Gcode and the last is greater than the ramp section period
    // thus, we want to make the ramp input so our controller continues to behave in a linear manner and is not subjected to
    // large disturbances

    // calculate number of ramp sections (close enough approx of euclid algorithm to get gcf using floating point version of %)
    _ramp_sections = (_tot_travel_period - (fmodf(_tot_travel_period, _ramp_dt_period))) /_ramp_dt_period;   
    // calculate the time where the ramp section of specified length would not fit
    //no_ramp = _tot_travel_period - (_ramp_dt_period*ramp_sections);  
    if (_tot_travel_period <= _ramp_dt_period)
    {
        if (fmodf(_tot_travel_period, _ramp_dt_period) == 0)
        {
            // even division of ramp_dt_period into the total travel time, just make room for the current feed rate because the current setpoint will be included in the ramp
            _ramp_sections ++;
            _even = true;
        }
        else 
        {
            // generated ramp stops short of current setpoint because remaining time less than ramp_dt_period
            // make room for current setpoint and feed rate
            _ramp_sections +=2;
        }

        _output_ramp = new float[_ramp_sections];   // the pointer to the dynamically allocated array can now be used like a normal array
        _output_ramp_time = new int16_t[_ramp_sections - 1];
    }
    
    else if (_tot_travel_period < _ramp_dt_period)
    {
        _ramp_sections = 2;
        _output_ramp = new float[_ramp_sections];
        _output_ramp_time = new int16_t[_ramp_sections - 1];
    }


}

/**  @brief    generates the ramp input to the control loop as a dynamic array
 *   @details  checks that the ramp should be generated by ensuring the total travel peirod 
 *             @c _tot_travel_period is greater than or equal to the discrete ramp period 
 *             and the dynamic memory allocation was successful such that the pointer
 *             @c _ouput_ramp is no longer a NULL pointer then, the ramp generator 
 *             for loop is run and the ramp input for the controller is generated. 
 *             (this is called output_ramp instead of input ramp because the motion planning
 *             class is outputs this, even though it is then taken and inputted into the 
 *             control loop).  @c ramp_generator() must be run after @c init_ramp() as the
 *             dynamic memory allocation is handled separately from the @c _output_ramp array
 *             population. 
 * 
 *   @param    index a variable to store the length of the dynamic array _output_array.
 *   @param    aug_index a variable that adjusts the index based on a specified quantity 
 *                       as a function of the @c _even boolean - true if the @c _ramp_dt_period
 *                       divided evenly into the @c _tot_travel_period and false if not.
 * 
 * 
 */
void MotionPlanning::ramp_generator(void)
{
    // the _output_ramp array is only populated if the previous memory allocation was successful in the init_ramp method
    
    // calculates the time required to move from last to current point in microseconds
    if ((_tot_travel_period >= _ramp_dt_period) && _output_ramp && _output_ramp_time)
    {
        int32_t index = 0;
        int8_t aug_index = 1;

           // array to hold ramp input to controller
        // setup for generation of ramp

        // if even division only change index by one to make room for current feed 
        if (_even)
        {
            aug_index = 1;
        }
        // for un-even division change index by two to make room for current setpoint and current feed
        else
        {
            aug_index = 2;
        }
        
        // generate the ramp via linear interpolation between the _current and _last setpoints in a for loop
        for (index=0; (index=(_ramp_sections - aug_index)); index++)
        {
            _output_ramp[index] = ((_setpoint_current - _setpoint_last) * index * (_ramp_dt_period / _tot_travel_period)) + _setpoint_last;
            _output_ramp_time[index] = _ramp_dt_period;
        }
        
        // Add desired final value or values to the ramp 
        if(_even)
        {
            _output_ramp[_ramp_sections] = _feed_setpoint;           // set the last value of the array to the value of the feed_setpoint 
            _output_ramp_time[_ramp_sections - aug_index] = _ramp_dt_period;
        }
        else
        {
            _output_ramp[_ramp_sections-1] = _setpoint_current;    // set penultimate value of the array to the value of the current setpoint
            _output_ramp[_ramp_sections] = _feed_setpoint;           // set the last value of the array to the value of the feed_setpoint 
            _output_ramp_time[_ramp_sections - aug_index] = fmodf(_tot_travel_period, _ramp_dt_period);
        }

    }

    // For very short or fast movements over sufficiently small distances - like the linear interpolation of arcs below a certain size
    // do not make a ramp. Instead put the current position setpoint and the feed setpoint into the array and make the class member data pointer
    // output ramp point to it.
    else if ((_tot_travel_period < _ramp_dt_period) && _output_ramp)
    {
        _output_ramp[0] = _setpoint_current;
        _output_ramp[1] = _feed_setpoint;
        _output_ramp_time[0] = fmodf(_tot_travel_period, _ramp_dt_period);
    }
    else
    {
        _output_ramp = NULL;
        _output_ramp_time = NULL;
    }
    

}

/**  @brief   get-er method to extract @c _output_ramp made by @c ramp_generator().
 *   @details gets the pointer @c _output_ramp which points to the first element of the
 *            dynamically allocated array that contains what will be the ramp input to the 
 *            control loop. Since this pointer is saved as class member data and set/reset
 *            by the constructor and de_init methods in this class the array is persistent 
 *            and does not need to be declared static.
 *   
 *   @returns @c _output_ramp the pointer to the first element in the ramp input dynamic array
 * 
 */
float * MotionPlanning::get_ramp(void)
{     
    return _output_ramp;        // returns the persistent reference to the dynamically allocated array _output_ramp
}

/**  @brief   deletes the dynamically allocated ramp input array and sets up for the next ramp
 *   @details In order to prevent memory leaks, since dynamic memory allocation is made use of 
 *            in this class, once all of the elements of @c _output_ramp[] have been passed into 
 *            the receiving control loop, this method must be called. The recommended workflow 
 *            is then to call this method once the previously generated ramp input had been successfully
 *            passed, in its entirety, to the control loop of interest and then call the @c update_setpoints()
 *            method to prepare the current instance of the MotionPlanning class for making the next ramp.    
 * 
 */
void MotionPlanning::deinit_ramp(void)
{
    delete [] _output_ramp;   // deallocate memory pointed to by *_output_ramp
    _output_ramp = NULL;      // make _ouput_ramp point back to NULL
    _ramp_sections = 0;       // zero out ramp sections so it is ready for the next ramp input
}

/**  @brief    a set-er function to update feed and position setpoints
 *   @details  Expects the current postion setpoint and current feedrate for the motor of interest
 *             from the new, current line of GCODE and sets the class member data for position and
 *             feed rate setpoints accordingly. This method should be called after the @c deinit_ramp()
 *             method is called within a loop.
 * 
 */
void MotionPlanning::update_setpoints(float current_setpoint, float current_feedrate)
{
    _setpoint_last = _setpoint_current;     // save what was the current setpoint to the last one
    _setpoint_current = current_setpoint;   // save the new current setpoint to class member data
    _feed_setpoint = current_feedrate;      // save the new current feed rate to class member data
}

/**  @brief   gets the pointer to the first element in the @c _output_ramp_time array 
 *   @details a simple get-er function that should be called within a for loop while asking
 *            for what the pointer points to at the specified index in order to unload the 
 *            the dynamically allocated time array. This array holds the time period that the
 *            @c distributer_task will update the control loops queues in the @c control_task
 *            with, and  is accomplished by setting the value of the @c vTaskDelay() in the
 *            @c distributer_task to the desired delay period. 
 *  @returns  @c _output_ramp_time pointer to the first element of the persistent dynamic array for ramp update times.
 */
int16_t * MotionPlanning::time_to_wait(void)
{
    return _output_ramp_time;
}

/**  @brief get-er method for getting the length of the ramp @c _ramp_sections
 *   @details makes the length of the _output_ramp available to outside functions
 *   @returns @c _ramp_sections the class member data for the length of the ramp input (output_ramp)
 * 
 */

uint32_t MotionPlanning::get_ramp_len(void)
{
    return _ramp_sections;
}